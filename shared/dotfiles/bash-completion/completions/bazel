_bazel_complete() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local prev="${COMP_WORDS[COMP_CWORD-1]}"
  local prevprev="${COMP_WORDS[COMP_CWORD-2]:-}"

  # Bazel subcommands: bazel r<TAB> -> run
  if [[ "$prev" == "bazel" ]]; then
    local cmds="build run test query clean info"
    COMPREPLY=($(compgen -W "$cmds" -- "$cur"))
    return
  fi

  # Manage scripts: bazel run redo/manage:<TAB>
  # Colon is a word break, so "redo/manage:foo" becomes ["redo/manage", ":", "foo"]
  local manage_match=false prefix=""
  if [[ "$prev" == "redo/manage" && "$cur" == ":" ]]; then
    manage_match=true
  elif [[ "$prev" == ":" && "$prevprev" == "redo/manage" ]]; then
    manage_match=true prefix="$cur"
  fi

  if $manage_match; then
    local scripts=$(find redo/manage/src -name '*.ts' 2>/dev/null | sed 's|redo/manage/src/||; s|\.ts$||')
    COMPREPLY=($(compgen -W "$scripts" -- "$prefix"))
    compopt -o nospace
    return
  fi

  # Package path completion (handles both //path and path)
  # Uses .bazel-packages cache (generated by `bazel run refresh`)
  if [[ -f .bazel-packages && -n "$cur" ]]; then
    local prefix="" search="$cur"
    [[ "$cur" == //* ]] && prefix="//" && search="${cur#//}"
    COMPREPLY=($(compgen -P "$prefix" -W "$(cat .bazel-packages)" -- "$search"))
    compopt -o nospace
  fi
}

complete -F _bazel_complete bazel
